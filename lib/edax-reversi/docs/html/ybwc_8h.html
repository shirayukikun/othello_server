<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ybwc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ybwc.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Parallel search header.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="const_8h_source.html">const.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="settings_8h_source.html">settings.h</a>&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="ybwc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTask.html">Task</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNode.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTaskStack.html">TaskStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1d107d116293b1dddca4e5d3d2898d00"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structTask.html">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a1d107d116293b1dddca4e5d3d2898d00">Task</a></td></tr>
<tr class="separator:a1d107d116293b1dddca4e5d3d2898d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b09f37e675bcd48a01bf22155996872"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structNode.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a3b09f37e675bcd48a01bf22155996872">Node</a></td></tr>
<tr class="separator:a3b09f37e675bcd48a01bf22155996872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6d97001c7135d9b685cb67c5edee97"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structTaskStack.html">TaskStack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a6c6d97001c7135d9b685cb67c5edee97">TaskStack</a></td></tr>
<tr class="separator:a6c6d97001c7135d9b685cb67c5edee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a437b9433cffbb1678f4b3836015379a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a437b9433cffbb1678f4b3836015379a9">node_init</a> (<a class="el" href="structNode.html">Node</a> *, struct <a class="el" href="structSearch.html">Search</a> *, const int, const int, const int, const int, <a class="el" href="structNode.html">Node</a> *)</td></tr>
<tr class="memdesc:a437b9433cffbb1678f4b3836015379a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a node.  <a href="ybwc_8h.html#a437b9433cffbb1678f4b3836015379a9">More...</a><br /></td></tr>
<tr class="separator:a437b9433cffbb1678f4b3836015379a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6421c278aea40f8bd427162ef67b5da7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a6421c278aea40f8bd427162ef67b5da7">node_free</a> (<a class="el" href="structNode.html">Node</a> *)</td></tr>
<tr class="memdesc:a6421c278aea40f8bd427162ef67b5da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free Resources allocated by a node.  <a href="ybwc_8h.html#a6421c278aea40f8bd427162ef67b5da7">More...</a><br /></td></tr>
<tr class="separator:a6421c278aea40f8bd427162ef67b5da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678aa2719ad07c711a60dde906b43b8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a678aa2719ad07c711a60dde906b43b8c">node_split</a> (<a class="el" href="structNode.html">Node</a> *, struct <a class="el" href="structMove.html">Move</a> *)</td></tr>
<tr class="memdesc:a678aa2719ad07c711a60dde906b43b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structNode.html">Node</a> split.  <a href="ybwc_8h.html#a678aa2719ad07c711a60dde906b43b8c">More...</a><br /></td></tr>
<tr class="separator:a678aa2719ad07c711a60dde906b43b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d94b50c97eb2f01f91d90a4257288af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a4d94b50c97eb2f01f91d90a4257288af">node_stop_slaves</a> (<a class="el" href="structNode.html">Node</a> *)</td></tr>
<tr class="separator:a4d94b50c97eb2f01f91d90a4257288af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba10515dc550a8ff296d7135444af345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#aba10515dc550a8ff296d7135444af345">node_wait_slaves</a> (<a class="el" href="structNode.html">Node</a> *)</td></tr>
<tr class="memdesc:aba10515dc550a8ff296d7135444af345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for slaves termination.  <a href="ybwc_8h.html#aba10515dc550a8ff296d7135444af345">More...</a><br /></td></tr>
<tr class="separator:aba10515dc550a8ff296d7135444af345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039d815475c3a24fb19277ffe5ac4811"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a039d815475c3a24fb19277ffe5ac4811">node_update</a> (<a class="el" href="structNode.html">Node</a> *, struct <a class="el" href="structMove.html">Move</a> *)</td></tr>
<tr class="memdesc:a039d815475c3a24fb19277ffe5ac4811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a node.  <a href="ybwc_8h.html#a039d815475c3a24fb19277ffe5ac4811">More...</a><br /></td></tr>
<tr class="separator:a039d815475c3a24fb19277ffe5ac4811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781ff673f88edb3f80ef57929bb676af"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structMove.html">Move</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a781ff673f88edb3f80ef57929bb676af">node_first_move</a> (<a class="el" href="structNode.html">Node</a> *, struct <a class="el" href="structMoveList.html">MoveList</a> *)</td></tr>
<tr class="memdesc:a781ff673f88edb3f80ef57929bb676af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first move of the move list.  <a href="ybwc_8h.html#a781ff673f88edb3f80ef57929bb676af">More...</a><br /></td></tr>
<tr class="separator:a781ff673f88edb3f80ef57929bb676af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9fd3cec638a54850cae07a0cb78d0e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structMove.html">Move</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a8e9fd3cec638a54850cae07a0cb78d0e">node_next_move</a> (<a class="el" href="structNode.html">Node</a> *)</td></tr>
<tr class="memdesc:a8e9fd3cec638a54850cae07a0cb78d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next move of the move list.  <a href="ybwc_8h.html#a8e9fd3cec638a54850cae07a0cb78d0e">More...</a><br /></td></tr>
<tr class="separator:a8e9fd3cec638a54850cae07a0cb78d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed34f76d45e639e9aa9df95e9c405c5c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#aed34f76d45e639e9aa9df95e9c405c5c">task_loop</a> (void *)</td></tr>
<tr class="memdesc:aed34f76d45e639e9aa9df95e9c405c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main loop runned by a task.  <a href="ybwc_8h.html#aed34f76d45e639e9aa9df95e9c405c5c">More...</a><br /></td></tr>
<tr class="separator:aed34f76d45e639e9aa9df95e9c405c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f57d4811ae70c4188b8a858320e08b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a18f57d4811ae70c4188b8a858320e08b">task_help</a> (void *)</td></tr>
<tr class="separator:a18f57d4811ae70c4188b8a858320e08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5557bda3b3d583c0d75625ad38e6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#aec5557bda3b3d583c0d75625ad38e6c6">task_init</a> (<a class="el" href="structTask.html">Task</a> *)</td></tr>
<tr class="memdesc:aec5557bda3b3d583c0d75625ad38e6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a task.  <a href="ybwc_8h.html#aec5557bda3b3d583c0d75625ad38e6c6">More...</a><br /></td></tr>
<tr class="separator:aec5557bda3b3d583c0d75625ad38e6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4211cd630deb76d57a6dfd1b2d56f92e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a4211cd630deb76d57a6dfd1b2d56f92e">task_free</a> (<a class="el" href="structTask.html">Task</a> *)</td></tr>
<tr class="memdesc:a4211cd630deb76d57a6dfd1b2d56f92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources used by a task.  <a href="ybwc_8h.html#a4211cd630deb76d57a6dfd1b2d56f92e">More...</a><br /></td></tr>
<tr class="separator:a4211cd630deb76d57a6dfd1b2d56f92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832e8af79ee7c991d2c753acf1f2dfba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a832e8af79ee7c991d2c753acf1f2dfba">task_update</a> (<a class="el" href="structTask.html">Task</a> *)</td></tr>
<tr class="separator:a832e8af79ee7c991d2c753acf1f2dfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4fc1461e78cd5569318f9e19399e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#aaa4fc1461e78cd5569318f9e19399e50">task_search</a> (<a class="el" href="structTask.html">Task</a> *task)</td></tr>
<tr class="memdesc:aaa4fc1461e78cd5569318f9e19399e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel search within a <a class="el" href="structTask.html">Task</a> structure.  <a href="ybwc_8h.html#aaa4fc1461e78cd5569318f9e19399e50">More...</a><br /></td></tr>
<tr class="separator:aaa4fc1461e78cd5569318f9e19399e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420f8adfca45ac7324695e2420f96cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a420f8adfca45ac7324695e2420f96cb9">task_stack_init</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *, const int)</td></tr>
<tr class="memdesc:a420f8adfca45ac7324695e2420f96cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the stack of tasks.  <a href="ybwc_8h.html#a420f8adfca45ac7324695e2420f96cb9">More...</a><br /></td></tr>
<tr class="separator:a420f8adfca45ac7324695e2420f96cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdac34326307f8e9c5e8a7ac7b9cb3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#acdac34326307f8e9c5e8a7ac7b9cb3ed">task_stack_free</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *)</td></tr>
<tr class="memdesc:acdac34326307f8e9c5e8a7ac7b9cb3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources used by the stack of tasks.  <a href="ybwc_8h.html#acdac34326307f8e9c5e8a7ac7b9cb3ed">More...</a><br /></td></tr>
<tr class="separator:acdac34326307f8e9c5e8a7ac7b9cb3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893cd1dd8a88791df3b91a21da8223d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a893cd1dd8a88791df3b91a21da8223d1">task_stack_resize</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *, const int)</td></tr>
<tr class="memdesc:a893cd1dd8a88791df3b91a21da8223d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the stack of tasks.  <a href="ybwc_8h.html#a893cd1dd8a88791df3b91a21da8223d1">More...</a><br /></td></tr>
<tr class="separator:a893cd1dd8a88791df3b91a21da8223d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9bc15fd793d6136e5eee2061265c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a3a9bc15fd793d6136e5eee2061265c22">task_stack_stop</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *, const <a class="el" href="const_8h.html#ac42f73e8f44e1394023723bee2fb8811">Stop</a>)</td></tr>
<tr class="separator:a3a9bc15fd793d6136e5eee2061265c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2aefeafe1bef20f4e751e215f5f77e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTask.html">Task</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a0c2aefeafe1bef20f4e751e215f5f77e">task_stack_get_idle_task</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *)</td></tr>
<tr class="memdesc:a0c2aefeafe1bef20f4e751e215f5f77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, if available, an idle task.  <a href="ybwc_8h.html#a0c2aefeafe1bef20f4e751e215f5f77e">More...</a><br /></td></tr>
<tr class="separator:a0c2aefeafe1bef20f4e751e215f5f77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed0f93d293fd5037ccd171b53d2bd19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a6ed0f93d293fd5037ccd171b53d2bd19">task_stack_put_idle_task</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *, <a class="el" href="structTask.html">Task</a> *)</td></tr>
<tr class="memdesc:a6ed0f93d293fd5037ccd171b53d2bd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put back an idle task after using it.  <a href="ybwc_8h.html#a6ed0f93d293fd5037ccd171b53d2bd19">More...</a><br /></td></tr>
<tr class="separator:a6ed0f93d293fd5037ccd171b53d2bd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe276fadad617762a55209371c00b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#a0fe276fadad617762a55209371c00b71">task_stack_clear</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *)</td></tr>
<tr class="separator:a0fe276fadad617762a55209371c00b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e5efbbcaab6d8868ec6f5f2b2401e8"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ybwc_8h.html#ae4e5efbbcaab6d8868ec6f5f2b2401e8">task_stack_count_nodes</a> (<a class="el" href="structTaskStack.html">TaskStack</a> *)</td></tr>
<tr class="separator:ae4e5efbbcaab6d8868ec6f5f2b2401e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Parallel search header. </p>
<dl class="section date"><dt>Date</dt><dd>1998 - 2017 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Richard Delorme </dd></dl>
<dl class="section version"><dt>Version</dt><dd>4.4 </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a3b09f37e675bcd48a01bf22155996872" name="a3b09f37e675bcd48a01bf22155996872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b09f37e675bcd48a01bf22155996872">&#9670;&nbsp;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structNode.html">Node</a> <a class="el" href="structNode.html">Node</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A <a class="el" href="structNode.html">Node</a> is a position in the search tree, containing information shared with parallel threads. </p>

</div>
</div>
<a id="a1d107d116293b1dddca4e5d3d2898d00" name="a1d107d116293b1dddca4e5d3d2898d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d107d116293b1dddca4e5d3d2898d00">&#9670;&nbsp;</a></span>Task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structTask.html">Task</a> <a class="el" href="structTask.html">Task</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A <a class="el" href="structTask.html">Task</a> is a parallel search thread. </p>

</div>
</div>
<a id="a6c6d97001c7135d9b685cb67c5edee97" name="a6c6d97001c7135d9b685cb67c5edee97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6d97001c7135d9b685cb67c5edee97">&#9670;&nbsp;</a></span>TaskStack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structTaskStack.html">TaskStack</a> <a class="el" href="structTaskStack.html">TaskStack</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a781ff673f88edb3f80ef57929bb676af" name="a781ff673f88edb3f80ef57929bb676af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781ff673f88edb3f80ef57929bb676af">&#9670;&nbsp;</a></span>node_first_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structMove.html">Move</a> * node_first_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMoveList.html">MoveList</a> *&#160;</td>
          <td class="paramname"><em>movelist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first move of the move list. </p>
<p >This is thread/safe getter of the first move. If the search is stopped, or an alphabeta cut has been found or no move is available the function returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a> data. </td></tr>
    <tr><td class="paramname">movelist</td><td>List of moves. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first move of the list or NULL if none is available. </dd></dl>

</div>
</div>
<a id="a6421c278aea40f8bd427162ef67b5da7" name="a6421c278aea40f8bd427162ef67b5da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6421c278aea40f8bd427162ef67b5da7">&#9670;&nbsp;</a></span>node_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free Resources allocated by a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a437b9433cffbb1678f4b3836015379a9" name="a437b9433cffbb1678f4b3836015379a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437b9433cffbb1678f4b3836015379a9">&#9670;&nbsp;</a></span>node_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSearch.html">Search</a> *&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_moves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a node. </p>
<p >Initialize the various members of the node structure. The important part of the initialization establishes a master-slave relashionship between this node (the slave) and its parent (the master).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A potentially shared position. </td></tr>
    <tr><td class="paramname">search</td><td>The position searched </td></tr>
    <tr><td class="paramname">alpha</td><td>lower score bound. </td></tr>
    <tr><td class="paramname">beta</td><td>upper score bound. </td></tr>
    <tr><td class="paramname">depth</td><td>depth. </td></tr>
    <tr><td class="paramname">n_moves</td><td><a class="el" href="structMove.html">Move</a> count. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e9fd3cec638a54850cae07a0cb78d0e" name="a8e9fd3cec638a54850cae07a0cb78d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9fd3cec638a54850cae07a0cb78d0e">&#9670;&nbsp;</a></span>node_next_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structMove.html">Move</a> * node_next_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next move of the move list. </p>
<p >This is a thread/safe getter of the next move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a> data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next move of the list. </dd></dl>

</div>
</div>
<a id="a678aa2719ad07c711a60dde906b43b8c" name="a678aa2719ad07c711a60dde906b43b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678aa2719ad07c711a60dde906b43b8c">&#9670;&nbsp;</a></span>node_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool node_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMove.html">Move</a> *&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structNode.html">Node</a> split. </p>
<p >Here is the heart of the YBWC algorithm. It splits a node into two tasks. Splitting occurs if the following conditions are met:</p><ol type="1">
<li><b> the first move has been already searched</b>. The main principle of the YBWC algorithm. It avoids to split a cut-type node, for which searching a single move is enough, and thus diminish search-overhead.</li>
<li>search to do is deep enough. In order to diminish the overhead of the parallelism. Can be tuned through SPLIT_MIN_DEPTH.</li>
<li>the node has not been splitted yet. For a single position, only two tasks can run in parallel. The idea is to favor splitting elsewhere in the tree.</li>
<li>This is not the last move. The idea is to lose less time in waiting for the parallel task to terminate. Can be tuned through SPLIT_MIN_MOVES_TODO. If these conditions are met, an idle task is requested, first from an idle task of a parent node; then, if none is available, from the idle task stack storage. If no idle task is found, the node splitting fails.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Master node to split. </td></tr>
    <tr><td class="paramname">move</td><td>move to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the split was a success, false otherwise. </dd></dl>

</div>
</div>
<a id="a4d94b50c97eb2f01f91d90a4257288af" name="a4d94b50c97eb2f01f91d90a4257288af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d94b50c97eb2f01f91d90a4257288af">&#9670;&nbsp;</a></span>node_stop_slaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_stop_slaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a039d815475c3a24fb19277ffe5ac4811" name="a039d815475c3a24fb19277ffe5ac4811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039d815475c3a24fb19277ffe5ac4811">&#9670;&nbsp;</a></span>node_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMove.html">Move</a> *&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a node. </p>
<p >Update bestmove, bestscore and alpha value of the node, in case the move is the bestmove found so far. The function is thread-safe although it updates a shared resource. Double check lock is used as an optimization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>current node. </td></tr>
    <tr><td class="paramname">move</td><td>last evaluated move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba10515dc550a8ff296d7135444af345" name="aba10515dc550a8ff296d7135444af345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba10515dc550a8ff296d7135444af345">&#9670;&nbsp;</a></span>node_wait_slaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void node_wait_slaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for slaves termination. </p>
<p >Actually, three steps are performed here:</p><ol type="1">
<li>Stop slaves node in case their scores are unneeded.</li>
<li>Wait for slaves' termination.</li>
<li>Wake-up the master thread that may have been stopped.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4211cd630deb76d57a6dfd1b2d56f92e" name="a4211cd630deb76d57a6dfd1b2d56f92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4211cd630deb76d57a6dfd1b2d56f92e">&#9670;&nbsp;</a></span>task_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free resources used by a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f57d4811ae70c4188b8a858320e08b" name="a18f57d4811ae70c4188b8a858320e08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f57d4811ae70c4188b8a858320e08b">&#9670;&nbsp;</a></span>task_help()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * task_help </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec5557bda3b3d583c0d75625ad38e6c6" name="aec5557bda3b3d583c0d75625ad38e6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5557bda3b3d583c0d75625ad38e6c6">&#9670;&nbsp;</a></span>task_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a task. </p>
<p >Initialize task data members and start the task main loop <a class="el" href="ybwc_8c.html#ab4e8d78b9f601f7e1d614b9d1ea2b571" title="The main loop runned by a task.">task_loop()</a> within a thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed34f76d45e639e9aa9df95e9c405c5c" name="aed34f76d45e639e9aa9df95e9c405c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed34f76d45e639e9aa9df95e9c405c5c">&#9670;&nbsp;</a></span>task_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * task_loop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main loop runned by a task. </p>
<p >When task-&gt;run is set to true, the task starts a parallel search. In order to diminish the parallelism overhead, we do not launch a new thread at each new splitted node. Instead the threads are created at the beginning of the program and run a waiting loop who enters/quits a parallel search when requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL. </dd></dl>

</div>
</div>
<a id="aaa4fc1461e78cd5569318f9e19399e50" name="aaa4fc1461e78cd5569318f9e19399e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4fc1461e78cd5569318f9e19399e50">&#9670;&nbsp;</a></span>task_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parallel search within a <a class="el" href="structTask.html">Task</a> structure. </p>
<p >Here we share the search with a main parent task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to search with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fe276fadad617762a55209371c00b71" name="a0fe276fadad617762a55209371c00b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe276fadad617762a55209371c00b71">&#9670;&nbsp;</a></span>task_stack_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4e5efbbcaab6d8868ec6f5f2b2401e8" name="ae4e5efbbcaab6d8868ec6f5f2b2401e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e5efbbcaab6d8868ec6f5f2b2401e8">&#9670;&nbsp;</a></span>task_stack_count_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long task_stack_count_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdac34326307f8e9c5e8a7ac7b9cb3ed" name="acdac34326307f8e9c5e8a7ac7b9cb3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdac34326307f8e9c5e8a7ac7b9cb3ed">&#9670;&nbsp;</a></span>task_stack_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free resources used by the stack of tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>The stack of tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c2aefeafe1bef20f4e751e215f5f77e" name="a0c2aefeafe1bef20f4e751e215f5f77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2aefeafe1bef20f4e751e215f5f77e">&#9670;&nbsp;</a></span>task_stack_get_idle_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTask.html">Task</a> * task_stack_get_idle_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return, if available, an idle task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>The stack of tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An idle task. </dd></dl>

</div>
</div>
<a id="a420f8adfca45ac7324695e2420f96cb9" name="a420f8adfca45ac7324695e2420f96cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420f8adfca45ac7324695e2420f96cb9">&#9670;&nbsp;</a></span>task_stack_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the stack of tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>The stack of tasks. </td></tr>
    <tr><td class="paramname">n</td><td>Stack size (number of tasks). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ed0f93d293fd5037ccd171b53d2bd19" name="a6ed0f93d293fd5037ccd171b53d2bd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed0f93d293fd5037ccd171b53d2bd19">&#9670;&nbsp;</a></span>task_stack_put_idle_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_put_idle_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put back an idle task after using it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>The stack of tasks. </td></tr>
    <tr><td class="paramname">task</td><td>An idle task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a893cd1dd8a88791df3b91a21da8223d1" name="a893cd1dd8a88791df3b91a21da8223d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893cd1dd8a88791df3b91a21da8223d1">&#9670;&nbsp;</a></span>task_stack_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the stack of tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Stack to resize. </td></tr>
    <tr><td class="paramname">n</td><td>New stack size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a9bc15fd793d6136e5eee2061265c22" name="a3a9bc15fd793d6136e5eee2061265c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9bc15fd793d6136e5eee2061265c22">&#9670;&nbsp;</a></span>task_stack_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stack_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTaskStack.html">TaskStack</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>Stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a832e8af79ee7c991d2c753acf1f2dfba" name="a832e8af79ee7c991d2c753acf1f2dfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832e8af79ee7c991d2c753acf1f2dfba">&#9670;&nbsp;</a></span>task_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask.html">Task</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
